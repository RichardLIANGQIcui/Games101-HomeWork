一、简要总结光线追踪的原理：

就是要确定一个像素的颜色，那么怎么确定这个像素的颜色呢？
当然是从像素发出一根光线，沿着这根光线去找与场景中的物体的交点，找到后
再以该交点为起点继续投射光线，一直投射到最大次数为止。
那么如何求该交点的颜色，该交点的颜色值是等于再一次递归投射光线返回的颜色乘上一个影响因子
可以是反射率或漫反射系数、高光系数，当然最后一次一般是返回场景中的颜色。

那么光线追踪的好处相交冯模型的好处是什么呢？它是全局光照算法、考虑阴影、考虑透明材质的计算，
同时也是实现物理正确性，使渲染更加真实，所以可以说它是
现代图形学渲染技术中一种基于物理、真实的光线追踪算法。


二、从整个代码流程来解析光线追踪算法渲染场景物体的整个流程

1、main函数：
添加场景，设置不同材质的球体及三角形网格添加到场景中
这里就会跳到Scene类、和物体类，物体类又包括了球体类和三角形网格类的实现；

（1）物体类：Object
具备材质、折射率、漫反射系数、高光系数等属性，同时具有判断物体求交、获取交点属性等基函数。

（2）球形类：Sphere
具有半径、圆心和基类属性，球体的表面属性函数主要是获取法线N，N = 交点-球心再归一化，
它的求交函数原理就是交点减去圆心的长度等于球的半径，这里会得到关于t的一元二次方程，
然后调用global.hpp解一元二次方程得到离起点最近的t值。

（3）三角形网格类
这里用到了智能指针存储三角形网格的各种属性
包括三角形数量、每个三角形的顶点位置、三角形顶点的索引、纹理坐标（用来存储重心坐标）

那么通过构造函数实现网格：
分别利用unique_ptr<T[]>(new T[size])构造不同属性的指针，再通过memcoy函数开盘空间
 memcpy(vertices.get(), verts, sizeof(Vector3f) * maxIndex);

对于三角形的求交函数：
用到了重心坐标求解的原理，o+td = (1-b1-b2)*P0+b1*P1+b2*P2，
满足t>=eps&&b1>=eps&&b2>=eps&&(1-b1-b2)>=eps，才有交点。
这个算法用到了Moller-Trumbore算法，直接套用公式即可

那么整个网格的求交当然是遍历所有三角形求交即可，同样最后也是找到最近的一个三角形

（4）Scene类
那么有了以上物体类就可以构建一个场景
一个场景类需要宽、高、视角、场景背景颜色、场景递归深度，vector数组存放物体、光源
Add添加场景函数，这里注意在智能指针压入数组时用了move（）的形式
get()获取场景物体和光源函数

2、Render类
在main函数中构建好场景后就可以调用渲染器渲染场景并生成最后图片。

（1）先调用 r.Render(scene)函数

遍历每个像素，以摄像机为起点发出光线并经过该像素打到场景中，那么这里要做一个空间变化
即逆光栅化的一个过程，把像素坐标变为NDC坐标再变为摄像坐标空间，最后求出光线方向dir。

（2）将光线方向带入到castRay(eye_pos, dir, scene, 0)求光线追踪最终得到的像素颜色，并将颜色
存储到framebuffer中，用于后续图片的生成。在这个函数中，进行递归调用，首先将传入的光线
与场景中的物体进行相交判断，这里需要跳到trace函数

（3）trace(orig, dir, scene.get_objects())会返回一个optional结构的含交点属性的struct结构，
这个函数的返回对象可以当成bool变量，如果有交点的话就为true。在这个函数中会将该光线
与场景中所有物体进行相交判断，最后会存入最近相交点的一系列属性的struct，包括是什么物体，最小t值
三角形的索性、纹理坐标等。

（4）此时从trace出来后再回到castRay中进行着色
这里接着调用了物体类的getSurfaceProperties函数获取法线
然后利用switch (payload->hit_obj->materialType)结构根据不同的材质模型进行不同的计算

第一种就是具有折射和反射的材质
需要用refract（）折射方向和reflect（）求反射方向；这两个函数实际上都是画图可以推导出最后的公式
然后求反射和折射起点，再根据上述两方向就可以求得往折射和反射投出去的光线
同样也是带入到castRay中进行递归求解，递归出来后在通过fresnel求反射光占比kr，入射光占比1-kr
fresnel(const Vector3f& I, const Vector3f& N, const float& ior)函数同样也有自己的公式
最后将castRay递归得出的颜色*相对应的占比得到最终颜色

第二种只考虑反射同理是一样的

第三种DIFFUSE_AND_GLOSSY材质用到的是布林冯模型，地板会用的这种材质，所以这里会计算阴影

phong模型还是原来公式，说下这里怎么求阴影
从trace（）出来的第一个交点出发投射光线到光源，如果该射线上还与其它物体相交，并且
sqrt(tNear*tNear)<光源到第一个交点的距离，说明第一个交点处被遮挡了，自然这个像素的颜色就是黑色

（5）至此framebuffer就存储了castRay计算返回的颜色，然后利用fopen和fwrite、fclose写入到文件中
但是这里需要的注意的使用fopen会是不安全的，所以还需要预处理器中添加警告_CRT_SECURE_NO_WARNINGS


END



































